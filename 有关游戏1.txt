凌：因为Cocos2d-x里面也支持挺多的脚本引擎，包括Lua、JavaScript还有C++。大家都知道C++有很多内存泄露、崩溃，很难解决。而且崩溃了也不会给你什么有用的Crash信息。

我们做游戏运营，当用户的游戏Crash掉之后，我们要能拿到他的数据。为此我们自己打造了一整套Crash工具，从网上可以直接拿到Crash信息，分析用户的堆栈。用了脚本引擎，就可以降低Crash率。

为什么选择了Lua，而没有选择JavaScript？因为JS太复杂了，很难控制它。而整个的Lua就500K代码，你自己吃透它非常简单，没几行代码就读完了。同时我们也自己改了一些脚本，加了一些函数。对于JavaScript语言来说，它的状态机太复杂了。支持匿名函数，又支持各种各样的Funtion，使得状态机异常复杂，它的解析器也很复杂。我想我们会用更简单的语言，那就是Lua。
并且Lua和C贴的是最紧凑的，我们要写个接口非常简单。Lua也有许多插件，用Lua在Java、OC和C之间互相调用都非常简单。

但是Lua也不是没有问题，它也有多线程的额问题，线程安全这块你要自己解决。这块技术，Lua还是比较复杂的。但是Lua主要业务是逻辑，至于考虑到多线程的问题，我们会有个专门的引擎组去解决，这是一队技术最好的程序员。游戏的逻辑会写在机要线程里面，所以这方面关系不大。引擎组去做多线程的事儿，和我们用到的Lua特性，关系不大。

对于游戏的开发人员，最好不要去碰多线程的东西，多线程容易出错。这里的技术选型，主要考虑的：一个是性能，一个是控制力。用Lua和C的效果基本上差不多，能有80%的效率。这也要看应用的场景，如果你是密集型运算，那可能性能还要差一些，但是LuaJIT的加速已经很快了。在iOS上性能提升5~6倍，在Android上可以达到60倍。

CSDN：这个Cocos2d-x和Lua定下来之后，你们都做了哪些工作？ 

凌：我们自己做的东西还是挺多的，我们自己做了Lua的调试器，我们用的是一个开源的ZeroBrane，在这之上自己修改的。可以说这是全世界最快的Lua调试器，把我们的Lua调试器性能提高了120倍。支持symbols和文件的快速定位，支持Push to device，改善了智能提示。
另外，我们做了一个资源管理器，可以做到增量更新、安全下载、安全加载、动态更新四个重要的功能。

比如在用户的本地apk里面，某些文件比较比较旧了，需要从网上下载一个文件，系统需要有一个缓存目录，去存放从远端下载的内容，然后再更新到本地apk目录里，这三个目录的同步，就是资源管理器要做的事情。

现在的游戏包一般都很大，100~200MB的有很多，甚至有的超过1GB了。所以说要做增量更新。我们有大小包部分，一般你先留一个小包，也看不同的市场。比如说有些网络好的市场，我们小包就行了。有些网络差的市场，我们就用大包。未来游戏更新的时候，我们都可以用增量更新，不用重新下大包。

考虑中国很多用户用2G网络下载不方便，所以在中国市场，肯定要用大包，有WiFi网络的时候把整包下了就行。但是在日本市场，你完全可以用小包，十几MB的包，效果最好。十几MB的包一般来说，里面有基本的资源，让你能进去，有个首页。进去之后按场景下载，这个是按需下载。

你进某个场景的时候，突然有个人冒出来，他骑了条龙，你边没有这个资源，你需要从远端下载完了之后，他才能够穿上去。这里面就有个问题，游戏希望这个人能出现，但是这个人出现的时候他没资源，怎么办？一般的做法是这个人先裸身，先别穿什么东西，就是一个简单的朴素装。后台从远程下完之后，再把它穿上去，这就叫做动态加载。

我们是参考git的设计去做资源管理器的，今后如果可能，资源管理器其实完全可以基于git去做，这样更方便静态资源的部署.
CSDN：那么游戏每次启动的时候，需要做哪些版本校验呢？

凌：首先，我们的游戏内容，会有几个存储的地方。一个是apk/ipa中的存储，一个是CDN的存储；一个存储是存放更新文件的本地存储。配置在服务器上有个配置版本号。游戏启动后，会去调这个配置服务器找版本号。看配置版本号是不是跟我们本地的配置版本号一样。如果一样，你就不用去更新配置。如果不一样，就到静态服务器去拉他的配置。

我们每次文件都是增量更新的，不会覆盖原来的，我们文件名都不一样。它会取这个配置，取完这个配置再跟本地的文件系统进行一个对比。因为我们本地文件系统，为了保证他的一致性，全部是MD5校验。

上面刚才说了，一个是apk里面的存储，一个是Web上的存储，一个是Cache里面的存储。资源管理器会管理各处的存放的数据。没有就直接去下载。